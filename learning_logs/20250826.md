# color / image 웹페이지 꾸미기
## 배경 꾸미기 
### 배경에 그라데이션 넣기 
- 그라데이션 : 두 가지 이상의 색을 이용해 두 색을 점점 변화시켜가며 채색하는 방식.(웹 사이트에서 흔히 사용되지는 않음) 

https://showcases.yalco.kr/html-css/02-08/02.html
1. background 속성의 속성 값으로 linear-gradient(색1, 색2) 
2. linear-gradient(각도(deg), 색1, 색2) 
  - 참고 : deg -> drgree (도) 
3. linear-gradient(각도, 색1, 퍼센트값, 색2)
  - 이전까진 색상이 반반씩 나왔는데 첫 번째 색의 구간을 지정하는 방식으로 퍼센트값을 넣어준다.
4. linear-gradient(색1, 색2, 색3)
  - 참고 : linear-gradient(색1 퍼센트값1, 색2 퍼센트값2, 색3 퍼센트값3);

## 포지셔닝
HTML로 작성한 문서(웹 페이지)는 하나의 기기로만 여는 것이 아니기 때문에 상대적이다. 따라서 요소의 위치를 잡는데 포지셔닝이 매우 중요한 역할을 한다. 그것의 기초가 우리가 금요일에 배웠던 `<span>` 과 `<div>` 의 성격 차이였다. 그리고 어제 display: inline / block / inline-block를 배웠다.
### position 속성
참조
https://showcases.yalco.kr/html-css/02-09/01.html

- 특정 HTML 요소들이 해당 페이지에서 어떻게 배치될지를 설정하는데 사용.
- `position 속성은 부모 요소의 것이지 자식에게 대물림되지 않음.` -> yellow의 position 속성이 red로 이어지지 않음을 뜻한다.

1. static 
  - position 속성의 default 값으로 top / left 등의 위치 조정을 하더라도 위치 이동 x -> HTML 구조를 따르는 것.
2. relative
  - 상대적인, 이라는 의미로 위치 이동이 가능.
  - 자신의 HTML 구조 상에서의 위치에서 이동하게 된다.
  - 해당 요소의 위치가 이동하지만 요소가 차지하는 공백은 그대로 유지가 됨.
    -> 그 결과 가장 상위 div의 범위를 아예 벗어난다고 하더라도 6번 div가 5번 자리로 이동하지 않음

3. absolute 
  - 절대적인 이라는 의미로 `첫 부모 요소(static이 아닌 상태로 만나는 상위 HTML 구조)`의 속성값을 이용해 위치 이동이 가능(relative랑 다른 좌표가 필요하다.)
  - 이상의 경우는 또 relative와 달리 공백 요소를 고정하지 않고 첫 부모의 좌표를 따라서 움직이기 때문에 공백이 생기게 될 경우 다음 div(여기선 6번)이 위치 이동을 하는 것을 볼 수 있다. 위치 이동이 일어나는 이유는 display: inline-block 때문이다.
  - 그래서 .yellow가 static인 상태로 .red를 postion: absolute; top: 100px; left: 100px;로 잡을 경우 .yellow가 `첫 부모가 아니기 때문에` 그 상위인 .outer가 첫 부모 요소가 되고 때문에 회색 borderline을 가진 div 기준으로 아래로 100px, 오른쪽으로 100px 이동한 위치가 된다.
  - .yellow의 position을 relative로 잡게 되면 첫 부모 요소가 되기 때문에 노란색 div 기준으로 아래쪽으로 100px, 오른쪽으로 100px 이동한 위치로 .red가 이동하게 된다.

4. fixed 
  - 고정된 이라는 의미로 부모 요소가 아니라 뷰포트(viewport)를 기준으로 위치를 지정함. 그래서 .outer보다 더 위에 있는 브라우저 흰색 부분을 기준으로 하기 때문에 똑같이 .red를 top: 100px; left: 100px;을 적용하더라도 위치가 약간 위/왼쪽으로 이동하는거다.
  - 뷰포트에 '고정된' 위치를 사용하기 때문에 브루아저의 스크롤링에 영향을 받지 않는다.
    - 해당 속성을 사용하게 될 경우 특정 팝업창을 띄웠을 때 스크롤과 상관없이 한 곳에 고정시킬 때 자주 사용하는 속성이다.

5. sticky
  - 특정 요소가 스크롤로 이동할 수 있는 공간을 top / bottom / left / right / z-index 속성값을 이용해 지정 가능함.
  - 예를 들어 홈페이지에서 nav에 해당하는 부분이 일정 수준까지는 아래로 스크롤링했을 때 따라 내려오는데 그 부분을 지나게 되면 따라오지 않는 등의 효과를 줄 때 사용함.

  - 부모 요소의 여백에 영향을 받음. 자식 요소의 위치를 고정하더라도 스크롤 하면서 부모 요소의 위치를 벗어난다면 자식 요소는 그 이상 움직이지 못함. 이상을 이유로 sticky는 부모 요소의 안쪽이 아니라 동등 / 바깥쪽 요소에 지정하는 것이 좋다.

### z-index 속성

https://showcases.yalco.kr/html-css/02-09/02.html

- static이 아닌 모든 경우에 각 요소들간에 높이 차이를 주게 됨으로써 요소들간의 배치를 효율적으로 하기 위한 값
- 겹쳐지는 순서를 인위적으로 바꾸고자 할 때 사용함.
- z-index의 default 값은 auto로 설정되있는데 이는 0을 의미함.
- 0보다 큰 값을 지니고 있다면 상위로 올라가게 됨.
- 이상을 이유로 광고창 등의 경우 무조건 상위에 있어야하기 때문에 css파일 확인해보면 z-index: 999; 같은 것도 구경할 수 있다.

# flex 레이아웃
- 모든 웹사이트는 큰 레이아웃 형태의 구조로 되어있고, 이 레이아웃을 만드는 방법은 다양합니다. 예전에는 HTML 테이블 구조와 블록/인라인의 조합으로 사이트 구조를 만들어야 했는데, 오늘날 flex가 나오면서 각종 CSS 기능을 통해 레이아웃을 설정하게 되었습니다.
# 부모에 적용하는 flex
참조 
https://showcases.yalco.kr/html-css/02-11/01.html

- 참고 : 부모에 적용하는 속성이라는 것은 부모 관련 css에 작성한다는 뜻으로 사용합니다.

참조 사이트를 기준으로 바깥쪽 div에 display: flex;를 적용했을 때와 display: inline-flex;를 적용했을 때의 p 태그 위치가 바뀌는 점을 확인할 수 있습니다.

이상의 차이에서 확인할 수 있는 점 :
1. display: flex;를 div에 적용했을 경우 block 성질은 그대로 유지된 상태로 flex가 적용됨
- 그래서 p 태그가 개행된 상태로 출력
2. display: inline-flex;를 div에 적용했을 경우 block 성질이 inline으로 바뀌게 되면서 회색 div 영역 이후의 부분에 p 태그의 텍스트가 출력됨.
3. flex-direction 속성
- 내부의 자식 요소들을 어느 축을 기준으로 정렬할지 결정.
- default 값은 row(왼쪽부터 차례대로 정렬함) -> 자식 요소들을 row로 정렬하기    때문에 참조 사이트 기준 1, 2, 3 div가 세로로 길게 출력됨.
2. justify-content
- 메인 축에서 내부 요소를 정렬하는 방식을 결정.
- default 값은 flex-start : 왼쪽부터 내부 요소 정렬
- center : 텍스트 중앙 정렬한 것처럼 내부 요소들을 중앙에 배치함.
- flex-end : 메인 축의 끝 부분인 오른쪽으로 내부 요소가 정렬됨. 순서는 flex-direction을 따릅니다.
- space-between : 맨 왼쪽과 오른쪽에 하나씩 배치하고 그 사이에 나머지 요소들을 균등하게 배치
- space-around : 각 내부 요소의 양쪽에 일정한 크기의 빈 공간을 배치. -> 1번 div 좌우에 margin처럼 보이는 애가 있고, 2번 div의 좌우에 margin이 있는 것처럼 보여서 중간 부분만 뻥 비어보입니다.
- space-evenly : 모든 빈 공간의 크기를 고르게 지정
3. align-items : flex의 메인 축에서의 반대편 축에서(즉 flex-direction: row;라면 y축 방향으로, flex-direction: column;이라면 x축 방향으로) 내부 요소를 정렬할 방식을 결정함.
- () 내부의 내용을 토대로 flex-direction: row;라면 반대 방향인 세로 방향으로 stretch가 일어나서 세로로 긴 div이 3 개 생겼다고 볼 수 있겠습니다.
- stretch : align-items의 default값으로 이상의 설명처럼 길게 늘립니다.
- flex-start : min-width / min-height의 크기 그대로 정렬하는 위치를 왼쪽 상단으로부터 시작함.
- center : 중앙 정렬
- flex-end : 수직 축의 끝 부분인 아래로 정렬
- 참고 : display:flex / flex-direction / align-items는 대부분 세트로 같이 돌아다니기 때문에 이 사이트에서 이리저리 움직여보고 css 값을 넣어보는 것도 좋은 방법입니다.
- flex-wrap
내부 요소들이 자식 요소의 영역을 넘어가는 부분을 전제로 배치 방식을 자동으로 바꿔주는 속성값
- default 값 : no-wrap
wrap으로 설정하게 되면 내부 요소가 부모 요소를 넘어가지 않도록 줄바꿈이 일어남. 주로 컨텐츠가 한 줄이 아니라 여러 줄일 때 사용
- 페이지 상에서의 효과를 보면 min-width / min-height를 가지고 있는 상태에서 최대한 stretch가 적용되어 부모 div의 영역을 차지하는 것을 확인할 수 있습니다. 만약에 그게 보기 싫으면 stretch를 flex-start / center / flex-end로 바꾸면 되죠.
5. align-content
- align-items와 혼동이 일어나기 쉽습니다. align-items의 경우에는 flex-start / center / flex-end를 적용했을 경우 가운데 여백이 같은 크기의 공백으로 나뉘어진 상태에서 내부 요소가 위 / 중간 / 아래에서 정렬이 일어납니다. 그래서 첫째줄과 둘째줄 사이에 공백이 있습니다.
- 반면 align-content를 사용했을 경우 1번 ~ 12번 div이 하나의 묶으로 공백없이 정렬된 상태에서 위 / 중간 / 아래에 정렬이 일어납니다.
- gap - 내부 요소들 사이에 들어가는 공백의 크기를 지정(그러니까 자식 div에 margin 적용하는거랑 혼동하기가 쉽습니다).
## 자식에 적용하는 flex
1. flex-basis / flex-shrink
- 자식에 flex 관련 속성을 사용하기 위해서는 부모의 css에 disply: flex;가 적용되어있어야 합니다. 그리고 아까 위에서 말한 것처럼 세트인 flex-direction을 적용해야 합니다. 이제 설명하는 부분은 flex-direction: row;를 기준으로 합니다.
- `부모 요소에서 flex-direction: row;` 이므로 자식 요소에서의 flex-basis는 row 방향으로의 크기를 지정합니다.
- default 값은 auto;
- 절대값 / 상대값을 적용할 수 있습니다.
- 만약에 자식 요소의 flex-basis를 절대값으로 잡는 바람에 부모 요소의 크기를 거기에 맞춰서 강제로 증가시키게 된다면 반응형 페이지라고 할 수 없을 겁니다.
- 해당 경우에 사용하는 것이 flex-shrink입니다.
- default 값 : 1
  - 전체 공간이 부족할 경우 해당 내부 요소의 크기가 컨텐츠(여기서는 주황색 div)의 width 또는 flex-basis의 최대 크기가 부모 요소를 넘어가지 못하도록 강제하는 값
2. flex-grow
- default 값 : 0 - 기존의 크기를 그대로 유지함
- 숫자의 크기에 따라 나머지 형제 요소들의 공백 크기의 곱만큼 자기가 커집니다.(커지는 방향은 부모의 flex-direction 설정값에 따름).

## 요소를 감추는 방법
1. 원래 보이던 요소를 투명하게 만드는 방법
2. 요소가 보이지 않으면서 가지고 있는 기능 자체도 날리는 방법
## CSS에서 요소를 숨기는 세 가지 방법
1. opacity 속성 활용
- 불투명도를 뜻하며 범위는 0 ~ 1 사이의 값. 0으로 하면 불투명도 0이기 때문에 투명해집니다.
- 해당 요소를 투명하게 만드는 것이기 때문에 기능은 존재합니다.
- 예전에 악성 광고 사이트 같은데서 많이 쓰던 방법인데 광고팝업을 opacity: 0;로 설정해서 클릭하면 광고 페이지로 넘어가게 하는 방식이었습니다.
2. visibility 속성 활용
- visibility의 속성값 : visible / hidden 두 가지로, hidden을 경우에 숨겨짐
- 기능도 사라집니다.
- 그런데 공백은 남아있어요. 보이냐 안보이냐만 지정했기 때문에 그냥 안보이는 상태에서 기능해제까지 도입되었다고 볼 수 있겠습니다.
3. display 속성 활용
- 얘는 많은 속성값이 있었습니다. 저희가 배운 것만 해도
- flex
- block
- inline
- inline-block
- 그런데 참조 사이트에는 div 들이 일렬로 나열돼야 하기 때문에 inline-block만 나와있었습니다.
- 그리고 none을 쓰게 되면
  - 눈에 안보이고 / 기능 삭제 되고 / 아예 없는게 되기 때문에 뒤에 있던 div가 앞으로 밀려오는 것까지 확인할 수 있습니다.
  
참조 https://showcases.yalco.kr/html-css/02-10/02.html
# CSS 고급 기능(이지만 최근엔 필수인)
## 반복 및 공통되는 스타일 
- CSS를 사용하다보면 여러 페이지에서 같은 코드를 반복해서 사용하는 일이 생긴다. CSS에서 공통적으로 사용되는 코드를 '모듈화'하여 다른 CSS 파일로 임포트하는 방법 그리고 자주 사용하는 속성값을 변수명으로 지정하는 방법

### 다른 CSS 파일을 임포트하기
형식 : 
`@import url(불러올 CSS 파일 경로)`

ch07_applied_style
01_cssimport.html / 01_cssimport.css / 00_shared.css

```html
/* 외부 css 파일 import*/
/* @import url(./00_shared.css); */

body {
  margin: 0;
  padding: 24px;
}
```
```css
/* 외부 css 파일 import*/
/* @import url(./00_shared.css); */

body {
  margin: 0;
  padding: 24px;
}
```
이상의 결과 화면을 확인했을 때 HTML 문서상에서 .sr-only 클래스명을 사용한 `<p>` 태그 내용이 보이지 않도록 숨겨지는 것을 확인할 수 있다. 이는 특정 문단의 내용(혹은 div일 수도 있겠네. class는 공유 가능하니까)을 감추는 설정이 담긴 shared.css 파일을 @import를 통해 외부에서 가지고 와서 01_cssimport.css에서 사용했기 때문이다.

이상처럼 HTML 문서를 사용할 때에 CSS를 적용하는 방식으로 
1. inline 방식
2. internal style sheet(내부 스타일 시트) 방식
3. linking style sheet(링킹 스타일 시트) 방식
으로 CSS 첫 시간에 수업을 했었는데
이제 외부 CSS를 가지고 오는
4. @import (임포트 방식)
을 들 수 있겠다.
상황에 따라서 선택 가능하다.

### CSS 변수 사용하기
- 변수(variable) : 특정한 데이터에 이름을 붙이는 것을 의미함.

예를 들어 .html을 생성할 때마다 body 태그 내에 bgcolor="5f5f5f"를 집어넣어왔는데 
저건 그나마 쉬우니까 그만인데 크림슨바이올렛 같은 색깔의 HEX 값을 외우고 있다가 3일 뒤에 물어보면 대답할 수 있을까 ? 값 하나만 틀려도 다른색이 튀나오니까 기억하기 쉬운 이름 즉 변수를 붙이면 사용하기가 훨씬 편하다. -> 영어권 사람들한테나 그렇고 한국인들한텐 조금 더 쉬워졌다 수준이다.

-CSS에서 변수를 나타낼 때는 원하는 변수명을 지정하고 그 앞에 `--` 입력해서 변수임을 표시한다. 예를 들어 디자이너와 프론트엔드 개발자 간에 소통하게 될 때 특정 색깔을 브랜드 메인 컬러로 설정했다면 
`--color-main` 그 다음 서브 컬러라면 `--color-sub1`과 같은 식으로 지정하는거다.
가장 작은 폰트 사이즈를 지정한다면 `--font-small` 과 같은 방식이 된다.

02_cssvariable.html / 02_cssvariable.css / 00_common.css

현재 상황을 고려했을 때 00_common.css 에서 공통적으로 사용되는 변수 목록들을 설정했다.
디자이너들이 정해주는 폰트 크기 색상, 자간, 줄 간격 등을 모조리 변수화한 다음에 특정 프로젝트 전용으로만 쓰는 편이다.

그리고 02_cssvariable.css에서 `@import url(./00_common.css)`를 통해서 _해당 파일의 변수 목록을 참조할 수 있도록 import 문을 작성_ 했다.

- var() -> 특정 CSS 변수의 데이터값을 불러오는 함수 

근데 i태그의 class="not-good" / b태그의 class="wrong"을 적용했을 때에는 아무런 차이가 없다.
p 태그에 공통적으로 적용한 부분만 나왔다.
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CSS 변수 사용 방법</title>
  <link rel="stylesheet" href="./02_cssvariable.css">
</head>
<body>
  <h1>
    제목 부분입니다.
  </h1>
  <p>
    <u class="not-good">
      u태그의 not good을 적용한 부분이다.
    </u>
    <br>
    <u class="wrong">
      u태그의 wrong을 적용한 부분이다.
    </u>
  </p>
  <p>
    <i class="not-good">
      u태그가 아닌 공통 부분의 not good을 적용한 부분이다.
    </i>
    <br>
    <b class="wrong">
      u태그가 아닌 공통 부분의 not good을 적용한 부분이다.
    </b>
  </p>
</body>
</html>
```
이상의 부분만 확인했을 때에는 i 태그와 u태그의 class가 동일하기 때문에 동일한 css가 적용될거라고 이전까지는 생각해왔다.

하지만 00_common.css를 확인했을 때 이하에서 볼 수 있듯이 u 태그에서만 --not-good / --wrong을 참조하도록 작성되있다. 즉 i태그에선 wavy underline orange;가 먹히지 않는다는 것이다. 이런 css 상에서의 위계 구조에 대해서도 알 필요가 있다.

물론 굳이 팀프로젝트 때 이렇게 골치아프게 설정하지 않을 수도 있다. 


```css
/* 특정 요소에서만 사용될 수 있는 변수 목록*/
u {
  --not-good: wavy underline orange;
  --wrong: wavy underline red;
}

.wrong {
  --warn: yellow;
}

/*
모든 요소에서 사용될 수 있는 변수
*/
:root {
  --font-small: 8px;
  --font-normal: 16px;
  --font-large: 24px;
  --font-x-large: 40px;
  --font-xx-large: 40px;
  --font-xxx-large: 48px;
  
/* 폰트 두께 변수 목록 */
  --font-w-normal: 400;
  --font-xxx-large: 600;
  --font-wwwwextrabold: 900;
}
```

- :root의 의미
  - 어떤 요소가 특정 태그 내에서만 사용되는 것이 아니라 페이지 전체에서 광범위하게 쓰이게 될 경우 사용하는 표현. 가상 클래스를 응용하고 root는 예약어로 전체 페이지를 의미한다.

이상의 import문과 그 응용 그리고 CSS 변수의 개념은 특정 페이지들의 합인 웹 서비스 상에서 공통된 요소와 특정한 요소 부분을 나눠 관리하는 것은 다른 사람과의 협업 체제에서 매우 중요한 부분 중 하나다.

## 벤더 프리픽스 
- trasition 속성
  1. -webkit-trainsition과 같은 방식으로 쓰이는데
    1. -webkit : 사파리 / 크롬 / 오페라
    2. -moz : 파이어폭스
    3. -ms : 엣지 / 익스플로러 
    4. -o : 구 버전 오페라 

표준이 정립되는 CSS 속성들의 경우에 각 브라우저가 구현하는대로 동작한다. 그래서 수업시간 중에 기본앱으로 chrome으로 고정하는 시간을 가졌다. 즉 사용자마다 서로 다른 UX를 가지게 될 수 있다는 의미다.

따라서 아직 표준화되지 않았거나 최신 기능이라 사용자의 브라우저가 구버전일 가능성이 있을 때 벤더 프리픽스를 먼저 붙여서 사용하고 공식 표준 속성은 맨 마지막에 작성한다.

왜냐면 CSS는 '순서대로' 덮어쓰기 때문에 일단 비표준으로 작성한 것이 후에 표준이 있다면 그걸로 덮어쓰기가 자동으로 이뤄지기 때문이다.

# 서체 스타일링

## 서체 및 웹 폰트(필수 / 구글 폰트 및 눈누 폰트 때문에) 

### Google Fonts 도입 방법
1. chrome 구글 폰트 검색(특히 한국어로 검색하는 것이 한글 폰트가 대문에 나온다.)
2. 그리고 별 문제가 없다면 Noto Sans Korean을 사용하게 되는데
  - Noto : No Tofu를 의미한다. 문자가 깨지는 빈 사각형 모양을 Tofu 라고 불렀었는데 Google에서 빡쳐서 절대 안깨지는 글씨체 만들겠다고 해서 각 국가별 Noto 시리즈가 잇다.
  - 모든 언어를 깔끔하게 표시할 수 있는 서체.
  - 다만 이상을 이유로 너무 보편적이라서 브랜드 사용시에는 적용되지 않는 편이다.

# JavaScript 
- 갖다놓는 HTML / 꾸미는 CSS라는 표현을 썼다. 그리고 특정 값의 변화 등을 시키는 역할은 JavaScript가 맡는다.

## 발생 배경
- 지금까지 HTML / CSS를 학습하면서 알 수 있는 점은 그냥 클릭 했을 때 뭐가 변하는 그런 부분이 아니라 웹 문서를 꾸미는 형태였다. 
- JS는 웹페이지를 _동적으로_ 만들기 위해 탄생한 언어다. 사용자가 버튼을 누르거나 특정 위치에 마우스를 올리거나 하는 등의 행위를 했을 때 상호작용을 할 수 있도록 하여 UX에 엄청난 영향을 끼친 언어라고 할 수 있다. 

## 주요 특징
1. 인터프리터 언어 : Java와 달리 Interpreter에 해당하기 때문에 오류나기 전까지는 실행이 된다.
2. 동적 타입(Dynamically Typed) : 변수를 선언할 때 타입을 미리 지정하지 않아도 된다. 코드를 실행 중에 지가 적당히 보고 나서 type을 결정한다. Java가 초반에 선언해야하는 점과 매우 차이가 있다.
  - 이게 처음엔 편하다 좋다 하면서 쓰고 있다가 보니까 다 작성하고 나서 테스트 할 때 돼서야 오류가 발생하는 경우가 많아서 TypeScript가 개발되기도 했다.
3. 객체 기반(Object-Based) : 클래스가 없이도 객체를 만들고 사용하는 것이 가능. 거의 모든 것이 객체로 취급된다(클래스가 없는).
4. 싱글 스레드(Single Thread) : 한 번에 하나의 작업만 순차적으로 처맇나다. 근데 비동기 처리 개념을 통해서 복잡한 작업을 효율적으로 처리하는 것은 가능하다.
## 장점 
1. 웹 브라우저의 기본 언어(language-HTML은 언어가 아니라 했다.) : 별도의 설치 없이 모든 웹 브라우저에서 실행된다.(vs code 설치할 때와 intellij 설치할 때 생각해보면 intellij때는 Java 버전을 다운 받았다.)
2. 유연한 문법 : Java를 배운 우리에겐 너무 자유롭다 싶겠지만 이게 초심자들에겐 장점에 해당한다.
3. 다양한 활용분야 : 웹 브라우저 외에도 서버(Node.js), 모바일 앱(React Native), 알고리즘까지 폭넓은 분야에서 사용된다.
4. 생태계 : NPM(Node Package Manager)라는 패키지 저장소를 통해 수많은 오픈소스 라이브러리와 프레임워크를 활용가능하다.
  - React는 Js의 프레임워크 중 하나다.
## 단점
1. 보안 : 웹브라우저에서 실행되다보니까 보안관련 설정을 많이 해줘야한다.(우린 Springboot를 통해 해줄 예정이다)
2. 느린 속도 : 이건 옛날 얘기
3. 예측 불가능한 오류 : 아까 장점이었던 유연한 문법에 관련된 문제로 실제로 테스트해보기 전까지 어떤 오류가 발생할지 짐작하기 어려운 점이 있었다. - TypeScript로 보완이 가능하지만 덕분에 우린 TypeScript도 배울 예정이다.
4. 브라우저 호환성 문제 : 이것도 옛날 문제인데 ES6 나오고 나서는 대충 다 해결 됐다.

```js
console.log('Hello, JavaScript!');
```
이상에서 보면 알 수 있듯이 얜 "" '' 구분 없이 '' 얘로 퉁친다.

그래서 앞으로의 수업 코드 작성 방식 :
HTML 태그 내에 있느 ㄴ속성값의 경우엔 ""를 쓸거고
JS 코드와 관련된 부분은 ''를 쓸거다.

근데 강사님이 반대로 쓰더라도 어차피 실행되니까 이 인간이 실수했구나 하면 된다.


03_webfont.html
